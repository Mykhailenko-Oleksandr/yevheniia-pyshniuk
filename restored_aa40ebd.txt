"use client";

import css from "./FeedbackFormModal.module.css";
import { createPortal } from "react-dom";
import { MouseEvent, useEffect } from "react";
import { useTranslations } from "next-intl";
import { useMutation, useQueryClient } from "@tanstack/react-query";
import { ErrorMessage, Field, Form, Formik, FormikHelpers } from "formik";
import * as Yup from "yup";
import toast from "react-hot-toast";
import { ApiError } from "@/app/api/api";
import { useAuthStore } from "@/lib/store/authStore";
import { createFeedback, CreateFeedbackData } from "@/lib/api/clientApi";
import StarsRating from "../StarsRating/StarsRating";

interface FormData {
  userName: string;
  comment: string;
  rating: number;
}

const createFeedbackFormSchema = (t: (key: string) => string) =>
  Yup.object({
    userName: Yup.string()
      .min(3, t("validation.userName.min"))
      .max(30, t("validation.userName.max"))
      .required(t("validation.userName.required")),

    comment: Yup.string()
      .min(10, t("validation.comment.min"))
      .max(100, t("validation.comment.max"))
      .required(t("validation.comment.required")),

    rating: Yup.number()
      .min(1, t("validation.rating.min"))
      .max(5, t("validation.rating.max"))
      .required(t("validation.rating.required")),
  });

interface FeedbackFormModalProps {
  isOpen: boolean;
  onClose: () => void;
}

export default function FeedbackFormModal({
  isOpen,
  onClose,
}: FeedbackFormModalProps) {
  const user = useAuthStore((state) => state.user);

  const tAriaLabel = useTranslations("ariaLabel");
  const t = useTranslations("feedbackFormModal");

  const queryClient = useQueryClient();

  const handleBackdropClick = (e: MouseEvent<HTMLDivElement>) => {
    if (e.target === e.currentTarget) onClose();
  };

  useEffect(() => {
    function onEsc(e: KeyboardEvent) {
      if (e.key === "Escape") onClose();
    }

    if (isOpen) {
      document.body.classList.add("noScroll");
      window.addEventListener("keydown", onEsc);
    } else {
      document.body.classList.remove("noScroll");
    }

    return () => {
      document.body.classList.remove("noScroll");
      window.removeEventListener("keydown", onEsc);
    };
  }, [isOpen, onClose]);

  const mutation = useMutation({
    mutationFn: (data: CreateFeedbackData) => createFeedback(data),
    onSuccess: () => {
      toast.success(t("toastSuccess"));
      onClose();

      queryClient.invalidateQueries({ queryKey: ["feedbacks"] });
    },
    onError: (error: unknown) => {
      const err = error as ApiError;

      toast.error(
        err.response?.data?.response?.validation?.body?.message ||
          err.response?.data?.response?.message ||
          err.message,
      );
    },
  });

  async function handleSubmit(
    values: FormData,
    formikHelpers: FormikHelpers<FormData>,
  ) {
    mutation.mutate({
      userName: values.userName.trim(),
      comment: values.comment.trim(),
      rating: values.rating,
    });

    formikHelpers.resetForm();
  }

  function capitalize(str?: string) {
    if (!str) return "";
    return str.charAt(0).toUpperCase() + str.slice(1).toLowerCase();
  }

  const userName =
    `${capitalize(user?.firstName)} ${capitalize(user?.lastName)}`.trim();

  return createPortal(
    <div className={css.backdrop} onClick={handleBackdropClick}>
      <div className={css.modalContent}>
        <button
          className={css.closeBtn}
          onClick={onClose}
          aria-label={tAriaLabel("closeModalBtn")}
        >
          <svg width="32" height="32" viewBox="0 0 32 32">
            <use href="/icons.svg#close" />
          </svg>
        </button>

        <Formik
          initialValues={{
            userName: userName || "",
            comment: "",
            rating: 0,
          }}
          onSubmit={handleSubmit}
          validationSchema={createFeedbackFormSchema(t)}
        >
          {({ isSubmitting, isValid, dirty, setFieldValue, values }) => (
            <Form className={css.form}>
              <fieldset className={css.fieldset}>
                <legend className={css.title}>{t("form.title")}</legend>
                <div className={css.inputWrapper}>
                  <label htmlFor="userName">{t("form.userName")}*</label>
                  <Field
                    id="userName"
                    name="userName"
                    type="text"
                    className={css.formInput}
                    placeholder={t("form.userNamePlaceholder")}
                  />
                  <ErrorMessage
                    name="userName"
                    component="span"
                    className={css.formError}
                  />
                </div>

                <div className={css.inputWrapper}>
                  <label htmlFor="comment">{t("form.comment")}*</label>
                  <Field
                    id="comment"
                    name="comment"
                    type="text"
                    as="textarea"
                    className={css.formInput}
                    placeholder={t("form.commentPlaceholder")}
                  />
                  <ErrorMessage
                    name="comment"
                    component="span"
                    className={css.formError}
                  />
                </div>

                <div className={css.rateInputWrapper}>
                  <StarsRating
                    rating={values.rating}
                    onChange={(newRate) => setFieldValue("rating", newRate)}
                  />
                  <ErrorMessage
                    name="rating"
                    component="span"
                    className={css.formError}
                  />
                </div>

                <button
                  type="submit"
                  className={css.btn}
                  disabled={isSubmitting || !isValid || !dirty}
                >
                  {t("form.button")}
                </button>
              </fieldset>
            </Form>
          )}
        </Formik>
      </div>
    </div>,
    document.body,
  );
}
